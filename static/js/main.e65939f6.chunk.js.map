{"version":3,"sources":["mp/GetSDK.ts","app/Frame.tsx","app/reusables/accordion/Accordion.tsx","app/reusables/accordion/AccordionItem.tsx","app/reusables/accordion/AccordionGroup.tsx","app/ui/Menu.tsx","app/utils.ts","app/Pathfinder.ts","app/sdk-components/PathRenderer.ts","app/sdk-components/CameraController.ts","app/sdk-components/index.ts","app/ui/MenuButton.tsx","app/App.tsx","index.tsx"],"names":["GetSDK","elementId","applicationKey","Promise","resolve","reject","intervalId","setInterval","a","iframe","HTMLIFrameElement","document","getElementById","contentWindow","sdkWindow","MP_SDK","clearInterval","sdk","connect","Frame","this","props","src","id","customRef","className","title","allowFullScreen","frameBorder","ref","Component","Accordion","header","children","ACCORDION_ITEM_HEIGHT","AccordionItem","body","selected","onClick","classNames","style","height","AccordionGroup","state","expanded","showChildren","setState","setTimeout","numChildren","Array","isArray","length","hasChildren","contentHeight","process","alt","Menu","sweepGroups","sweepData","groups","s","floor","push","onChange","selectedSweepId","sid","getGroups","floors","selectedFloor","undefined","Object","entries","sweeps","items","renderItem","onClose","type","renderGroups","distance","p1","p2","Math","sqrt","x","y","z","sweepIdToPoint","position","Pathfinder","VERT_THRESHOLD","HORZ_THRESHOLD","graph","path","sweepPositions","forEach","sweep","createGraph","i","sweep_a","adj","neighbor_sids","neighbors","j","sweep_b_sid","d","i_sid","j_sid","a_sid","b_sid","console","error","ht","visited","cost","parent","debug_n","min_sid","encountered_sids","keys","dist","penalty","heuristic","log","reverse","PathRenderer","material","inputs","visible","radius","color","opacity","heightOffset","stepMultiplier","context","outputs","curve","onInit","THREE","three","every","p","points","map","Vector3","spline","CatmullRomCurve3","extrudeSettings","steps","bevelEnabled","extrudePath","arcShape","Shape","absarc","PI","extrudeGeometry","ExtrudeGeometry","MeshBasicMaterial","transparent","pathMesh","Mesh","objectRoot","onEvent","_type","_data","onInputsUpdated","_previous","onTick","_tickDelta","onDestroy","dispose","pathRendererType","PathRendererFactory","CameraController","startTime","up","speed","verticalOffset","camera","PerspectiveCamera","copy","getPoint","updateProjectionMatrix","Date","now","getLength","time","tNow","tFuture","currPos","getPointAt","futurePos","matrix","Matrix4","lookAt","quaternion","Quaternion","setFromRotationMatrix","cameraControllerType","CameraControllerFactory","initComponents","all","Scene","register","MenuButton","text","defaultUrlParams","m","qs","hr","brand","help","play","App","frameRef","React","createRef","pathNode","pathfinder","flyNode","onOptionSelect","startFly","endFly","createNode","addComponent","camCon","cam","enabled","bind","Mode","moveTo","DOLLHOUSE","transition","TransitionType","INSTANT","start","stop","toggleMenu","menuEnabled","queryString","handleUrlParams","params","URLSearchParams","window","location","search","k","v","has","append","toString","Model","getData","Sweep","data","subscribe","onCollectionUpdated","collection","sweepMap","current","currentSweep","currSweepId","handlePath","findShortestPath","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.e65939f6.chunk.js","sourcesContent":["import { MpSdk, ShowcaseEmbedWindow } from './sdk';\n\nconst SDK_VERSION = '3.2';\n\n/**\n * Gets a reference to the SDK. Use this if you want to do SDK stuff.\n * @param {string | HTMLIFrameElement} elementId ID of the iframe or the iframe element itself\n * @param {string} applicationKey Your API key \n * @returns Promise of MpSdk reference\n */\nexport const GetSDK = function(elementId: string | HTMLIFrameElement, applicationKey: string): Promise<MpSdk> {\n  return new Promise(function(resolve, reject) {\n    const checkIframe = async function() {\n      let iframe = null;\n      if (elementId instanceof HTMLIFrameElement) {\n        iframe = elementId as HTMLIFrameElement;\n      }\n      else {\n        iframe = document.getElementById(elementId) as HTMLIFrameElement;\n      }\n\n      if (iframe) {\n        // sometimes this is undefined for some reason, so check for it\n        const sdkWindow = (await iframe.contentWindow as ShowcaseEmbedWindow).MP_SDK;\n        if (sdkWindow) {\n          clearInterval(intervalId);\n          const sdk = sdkWindow.connect(iframe, applicationKey, SDK_VERSION);\n          resolve(sdk);\n        }\n      }\n    };\n    const intervalId = setInterval(checkIframe, 100);\n  });\n}\n","import React, { Component } from 'react';\nimport './Frame.scss';\n\ninterface Props {\n  src: string;\n  id?: string;\n  customRef?: React.RefObject<HTMLIFrameElement>\n}\n\n/**\n * This component houses the actual Matterport IFrame element. Doesn't do anything else.\n */\nexport default class Frame extends Component<Props, {}> {\n  render() {\n    const { src, id, customRef } = this.props;\n    return (\n      <div className='frame'>\n        <iframe\n          id={id || 'showcase'}\n          className='frame'\n          src={src}\n          title={'showcase'}\n          allowFullScreen={true}\n          frameBorder='0'\n          ref={customRef}\n        >\n        </iframe>\n      </div>\n    );\n  }\n}\n","import { Component } from 'react';\nimport './Accordion.scss';\n\ninterface AccordionProps {\n  header?: string\n}\n\nexport default class Accordion extends Component<AccordionProps> {\n\n  public render() {\n    const { header, children } = this.props;\n\n    return (\n      <div className='accordion'>\n        { header &&\n          <div className='accordion-header'>{header}</div>\n        }\n        <div className='accordion-groups'>\n          {children}\n        </div>\n      </div>\n    );\n  }\n}","import classNames from 'classnames';\nimport { Component } from 'react';\nimport './AccordionItem.scss';\n\ninterface AccordionItemProps {\n  header?: string;\n  body?: string;\n  selected?: boolean;\n  onClick?: (e: any) => void;\n}\n\nexport const ACCORDION_ITEM_HEIGHT = '40px';\n\nexport default class AccordionItem extends Component<AccordionItemProps> {\n  public render() {\n    const { header, body, selected, onClick } = this.props;\n    return (\n      <div\n        className={classNames('accordion-item', {'selected': !!selected})}\n        onClick={onClick}\n        style={{ height: ACCORDION_ITEM_HEIGHT }}\n      >\n        <div className='accordion-item-details'>\n          <div className='accordion-item-header'>{header}</div>\n          <div className='accordion-item-body'>{body}</div>\n        </div>\n      </div>\n    );\n  }\n}","import { Component } from 'react';\nimport classNames from 'classnames';\nimport './AccordionGroup.scss';\nimport { ACCORDION_ITEM_HEIGHT } from './AccordionItem';\n\ninterface AccordionGroupProps {\n  header?: string;\n  expanded?: boolean;\n}\n\ninterface AccordionGroupState {\n  expanded: boolean;\n  showChildren: boolean;\n}\n\nexport default class AccordionGroup extends Component<AccordionGroupProps, AccordionGroupState> {\n  constructor(props: any) {\n    super(props);\n    const { expanded } = this.props;\n    this.state = {\n      expanded: !!expanded,\n      showChildren: !!expanded,\n    };\n  }\n\n  private onClick = () => {\n    const { expanded, showChildren } = this.state;\n    this.setState({\n      expanded: !expanded,\n    }, () => setTimeout(() => this.setState({showChildren: !showChildren}), showChildren ? 250 : 0));\n  }\n  \n  public render() {\n    const { children, header } = this.props;\n    const { expanded } = this.state;\n\n    let numChildren = 0;\n    if (children) {\n      if (Array.isArray(children)) {\n        numChildren = children.length;\n      } else {\n        numChildren =  1; // one child fails isArray check\n      }\n    }\n    const hasChildren = numChildren > 0;\n    const contentHeight = expanded && hasChildren ? `calc(${numChildren}*${ACCORDION_ITEM_HEIGHT})` : '0';\n\n    return (\n      <div className={classNames('accordion-group-container', {'collapsed': !expanded})}>\n        <div\n          className='accordion-group-header'\n          onClick={this.onClick}\n        >\n          {'' + header + (hasChildren ? ` (${numChildren})` : '')}\n          <img src={process.env.PUBLIC_URL + '/icons/chevron-down.svg'} className='accordion-icon icon-chevron-down' alt={'Toggle accordion group'} />\n        </div>\n        <div\n          className={classNames('accordion-group', {\n            'collapsed': !expanded,\n          })}\n          style={{ height: contentHeight }}\n        >\n          {numChildren > 0 && children}\n        </div>\n      </div>\n    );\n  }\n}","import { Component } from 'react';\nimport { Sweep } from '../../mp/sdk';\nimport './Menu.scss';\nimport Accordion from '../reusables/accordion/Accordion';\nimport AccordionGroup from '../reusables/accordion/AccordionGroup';\nimport AccordionItem from '../reusables/accordion/AccordionItem';\n\ninterface MenuProps {\n  currSweepId?: string;\n  selectedSweepId?: string;\n  sweepData: Sweep.SweepData[];\n  onChange: (e: any) => void;\n  onClose?: () => void;\n}\n\ninterface MenuState {\n  sweepGroups: SweepGroups;\n}\n\ninterface SweepGroups {\n  [group: string]: Sweep.SweepData[];\n}\n\n/**\n * Component for UI elements like sweep selector, location info, etc.\n */\nexport default class Menu extends Component<MenuProps, MenuState> {\n\n  constructor(props: any) {\n    super(props);\n    this.state = {\n      sweepGroups: {},\n    };\n  }\n\n  private getGroups() {\n    const { sweepData } = this.props;\n    const groups: SweepGroups = {};\n    for (const s of sweepData) {\n      const floor = '' + s.floor;\n      if (!(floor in groups)) {\n        groups[floor] = [];\n      }\n      groups[floor].push(s);\n    }\n    return groups;\n  }\n\n  private renderItem(s: Sweep.SweepData) {\n    const { onChange, selectedSweepId } = this.props;\n    const { sid } = s;\n    return (\n      <AccordionItem\n        header={sid}\n        onClick={() => onChange(sid)}\n        selected={sid === selectedSweepId}\n      />\n    );\n  }\n\n  /**\n   * Renders sweeps grouped by floors.\n   * @returns List of `<AccordionGroup>` with items inside.\n   */\n  private renderGroups() {\n    const { selectedSweepId } = this.props;\n    const sweepGroups = this.getGroups();\n    const floors: any = [];\n    let selectedFloor = undefined;\n\n    for (const [floor, sweeps] of Object.entries(sweepGroups)) {\n      if (!(floor in floors)) floors[floor] = [];\n      \n      const items = []\n      for (const s of sweeps) {\n        items.push(this.renderItem(s));\n        if (s.sid === selectedSweepId) {\n          selectedFloor = s.floor;\n        }\n      }\n\n      floors.push(\n        <AccordionGroup\n          header={`Floor ${floor}`}\n          expanded={!!selectedFloor && ''+selectedFloor === floor}\n        >\n          {items}\n        </AccordionGroup>\n      );\n    }\n    return floors;\n  }\n  \n  public render() {\n    const { sweepData, onClose } = this.props;\n    return (\n      <div className='menu'>\n        <div className='menu-header'>\n          <div className='menu-header-text'>{`Sweeps (${sweepData.length})`}</div>\n          { onClose &&\n            <button type='button' className='menu-close-button' onClick={onClose}>\n              <img src={process.env.PUBLIC_URL + '/icons/x-lg.svg'} className=' icon-x-lg' alt='Close' />\n            </button>\n          }\n        </div>\n        <Accordion>\n          {this.renderGroups()}\n        </Accordion>\n      </div>\n    );\n  }\n}","import { Dictionary, MpSdk, Vector3 } from \"../mp/sdk\";\n\n/**\n * This module is for general helper interfaces, types, and methods.\n */\n\n/**\n * Euclidean distance between two points.\n * @param {Vector3} p1 \n * @param {Vector3} p2 \n * @returns {number}\n */\nexport function distance(p1: Vector3, p2: Vector3): number {\n  return Math.sqrt((p1.x - p2.x)**2 + (p1.y - p2.y)**2 + (p1.z - p2.z)**2);\n}\n\nexport function sweepIdToPoint(id: string, sweepData: Dictionary<MpSdk.Sweep.ObservableSweepData>): Vector3 {\n  return sweepData[id].position;\n}\n\nexport {};","import { Sweep, Vector3 } from '../mp/sdk';\nimport { distance } from './utils';\n\n/**\n * Path given by `findShortestPath` as list of sweep ids. It's a separate type\n * just in case the return type changes.\n */\nexport type SweepPath = string[];\n\n/**\n * Graph as adjacency list, with sweep ids mapping to a list of neighboring ids,\n * who each map to corresponding distances.\n */\ninterface SweepGraph {\n  [a_id: string]: AdjacencyNode;\n}\ninterface AdjacencyNode {\n  [b_id: string]: number;\n}\n\nexport interface SweepPositions {\n  [id: string]: Vector3;\n}\n\nexport default class Pathfinder {\n\n  private VERT_THRESHOLD = 0.5; // penalize sweeps vertically separated by this distance, in meters\n  private HORZ_THRESHOLD = 10.0; // penalize sweeps horizontally separated by this distance, in meters\n\n  private graph: SweepGraph = {};\n  public path: SweepPath = [];\n\n  private sweepPositions: SweepPositions = {};\n\n  constructor(sweepData: Sweep.SweepData[]) {\n    // init sweepPositions\n    sweepData.forEach(sweep => this.sweepPositions[sweep.sid] = sweep.position);\n    this.createGraph(sweepData);\n  }\n\n  /**\n   * Generate graph of sweep distances.\n   * @param {Sweep.SweepData[]} sweeps List of sweep data, such as `sdk.Model.getData().sweeps`\n   */\n  private createGraph(sweeps: Sweep.SweepData[]): void {\n    const graph: SweepGraph = {};\n    for (let i = 0; i < sweeps.length; i++) {\n      const sweep_a = sweeps[i];\n      const adj: AdjacencyNode = {};\n      const neighbor_sids = sweep_a.neighbors;\n      for (let j = 0; j < neighbor_sids.length; j++) {\n        const sweep_b_sid = neighbor_sids[j];\n        const d = distance(sweep_a.position, this.sweepPositions[sweep_b_sid]);\n        adj[sweep_b_sid] = d;\n      }\n      graph[sweep_a.sid] = adj;\n    }\n    this.graph = graph;\n  }\n\n  /**\n   * Heuristic function for A*. Just take Euclidean distance.\n   */\n  private heuristic(i_sid: string, j_sid: string): number {\n    const { sweepPositions } = this;\n    return distance(sweepPositions[i_sid], sweepPositions[j_sid]);\n  }\n\n  /**\n   * Additional penalty to avoid large vertical/horizontal jumps.\n   */\n  private penalty(i_sid: string, j_sid: string): number {\n    const { sweepPositions } = this;\n    return ((sweepPositions[i_sid].y - sweepPositions[j_sid].y) / this.VERT_THRESHOLD) ** 4\n      + (((sweepPositions[i_sid].x - sweepPositions[j_sid].x) ** 2 + (sweepPositions[i_sid].z - sweepPositions[j_sid].z) ** 2) / this.HORZ_THRESHOLD);\n  }\n\n  /**\n   * Find shortest path between two sweeps connected by valid movements.\n   * @param {string} a_sid SID of starting sweep.\n   * @param {string} b_sid SID of ending sweep.\n   * @returns {SweepPath} Path from `a_sid` to `b_sid`.\n   */\n  public async findShortestPath(a_sid: string, b_sid: string): Promise<SweepPath | undefined> {\n\n    const { graph } = this;\n\n    // check SIDs are valid\n    if (graph[a_sid] === undefined || graph[b_sid] === undefined) {\n      console.error('Sweep SID(s) is invalid.');\n      return;\n    }\n\n    const ht: any = {}; // hash table that stores the following info for each encountered sweep:\n    ht[a_sid] = { visited: false, distance: 0, cost: 0, parent: null };\n\n    // loop A* algorithm\n    let debug_n = 0; // count number of iterations\n\n    while (true) {\n      debug_n += 1;\n      // find unvisited sweep with minimum cost = distance + heuristic\n      // TODO: optimize with priority queue\n      let min_sid;\n      const encountered_sids = Object.keys(ht);\n      for (let i = 0; i < encountered_sids.length; i++) {\n        const sid = encountered_sids[i];\n        if (!ht[sid].visited && (min_sid === undefined || ht[sid].cost < ht[min_sid].cost)) {\n          min_sid = sid;\n        }\n      }\n      if (min_sid === undefined) {\n        console.error('Could not find path; sweeps are not connected.');\n        return;\n      }\n      // check if sweep is ending point\n      if (min_sid === b_sid) {\n        break;\n      }\n      // add all neighbors of `min_sid`\n      ht[min_sid].visited = true;\n      const neighbor_sids = Object.keys(graph[min_sid]);\n      for (let i = 0; i < neighbor_sids.length; i++) {\n        const sid = neighbor_sids[i];\n        const dist = ht[min_sid].distance + graph[min_sid][sid];\n        const cost = dist + this.penalty(min_sid, sid) + this.heuristic(sid, b_sid);\n        if (sid in ht) { // if sweep has been encountered\n          if (!ht[sid].visited && (ht[sid].cost > cost)) { // if not visited and smaller cost, then update\n            ht[sid].parent = min_sid;\n            ht[sid].distance = dist;\n            ht[sid].cost = cost;\n          }\n        } else { // if sweep has not been encountered yet\n          ht[sid] = { visited: false, distance: dist, cost: cost, parent: min_sid };\n        }\n      }\n    }\n    console.log(`Pathfind iterations: ${debug_n}`);\n\n    // traverse graph back to starting point\n    let sid = b_sid;\n    const path: string[] = [sid];\n    while (ht[sid].parent !== null) {\n      sid = ht[sid].parent as string;\n      path.push(sid);\n    }\n    path.reverse();\n    return path;\n\n  }\n}","import { Color, Vector3 } from '../../mp/sdk';\nimport { distance } from '../utils';\n\ninterface PathRendererInputs {\n  visible: boolean;\n  path: Vector3[];\n  radius: number;\n  color: Color | number;\n  opacity: number;\n  heightOffset: number;\n  stepMultiplier: number;\n}\n\ninterface PathRendererOutputs {\n  objectRoot: any;\n  curve: any;\n  distance: number;\n}\n\nclass PathRenderer {\n\n  private material: any;\n\n  private inputs: PathRendererInputs = {\n    visible: false,\n    path: [], // positions on path\n    radius: 0.15,\n    color: 0x00ff00,\n    opacity: 0.5,\n    heightOffset: -1.1,\n    stepMultiplier: 5,\n  };\n\n  private context: any;\n\n  private outputs = {\n    curve: null,\n    distance: 0,\n  } as PathRendererOutputs;\n\n  public onInit = async () => {\n\n    const THREE = this.context.three;\n\n    const { path,\n            radius,\n            heightOffset,\n            opacity,\n            color,\n            stepMultiplier } = this.inputs;\n\n    // check if path is long enough and no undefined points\n    if (path.length < 2 || !path.every(p => !!p)) return;\n    \n    let d = 0;\n    const points = path.map((p, i) => {\n      if (i > 0) {\n        d += distance(path[i-1], p);\n      }\n      return new THREE.Vector3(p.x, p.y+heightOffset, p.z);\n    });\n    const spline = new THREE.CatmullRomCurve3(points);\n\n    const extrudeSettings = {\n        steps: stepMultiplier * path.length,\n        bevelEnabled: false,\n        extrudePath: spline,\n    };\n\n    // Shape to extrude\n    const arcShape = new THREE.Shape().absarc(0, 0, radius, 0, Math.PI * 2, false);\n    \n    const extrudeGeometry = new THREE.ExtrudeGeometry( arcShape, extrudeSettings );\n    \n    this.material = new THREE.MeshBasicMaterial({\n        color: color as number,\n        transparent: true,\n        opacity: opacity,\n    });\n\n    const pathMesh = new THREE.Mesh(extrudeGeometry, this.material)\n\n    this.outputs.objectRoot = pathMesh;\n    this.outputs.curve = spline;\n    this.outputs.distance = d;\n  };\n\n  public onEvent = function(_type: any, _data: any) {\n  }\n\n  public onInputsUpdated = function(_previous: any) {\n  };\n\n  public onTick = function(_tickDelta: any) {\n  };\n\n  public onDestroy = () => {\n    this.material?.dispose();\n  };\n}\n\nexport const pathRendererType = 'sdk-component.pathRenderer';\nexport function PathRendererFactory() {\n  return new PathRenderer();\n}","interface CameraControllerInputs {\n  curve: any,\n  speed: number,\n  verticalOffset: number\n}\n\ninterface CameraControllerOutputs {\n  camera: any,\n}\n\nclass CameraController {\n\n  private startTime: any;\n  private length: any;\n  private up: any;\n\n  private inputs: CameraControllerInputs = {\n    curve: null,\n    speed: 1.,\n    verticalOffset: 1.,\n  };\n\n  private context: any;\n\n  private outputs = {\n    camera: null,\n  } as CameraControllerOutputs;\n\n  public onInit = async () => {\n    const THREE = this.context.three;\n    console.log(\"start\");\n\n    const camera = new THREE.PerspectiveCamera( 45, 1.333, 1, 1000 );\n    this.outputs.camera = camera;\n    \n    camera.position.copy(this.inputs.curve.getPoint(0));\n    camera.position.y += this.inputs.verticalOffset;\n    camera.updateProjectionMatrix();\n\n    this.startTime = Date.now();\n    this.length = this.inputs.curve.getLength();\n    this.up = new THREE.Vector3(0, 1, 0);\n\n  };\n\n  public onEvent = function(_type: any, _data: any) {\n  };\n\n  public onInputsUpdated = function(_previous: any) {\n  };\n\n  public onTick = async (_tickDelta: any) => {\n    const THREE = this.context.three;\n\n    const time = (Date.now() - this.startTime)/1000;\n    const tNow = this.inputs.speed * time / this.length;\n    const tFuture = this.inputs.speed * (time + 1) / this.length;\n\n    // positions\n    const currPos = this.inputs.curve.getPointAt(tNow);\n    const futurePos = this.inputs.curve.getPointAt(tFuture);\n    this.outputs.camera.position.copy(currPos);\n    this.outputs.camera.position.y += 1.;\n\n    // rotation\n    const matrix = new THREE.Matrix4().lookAt(currPos, futurePos, this.up);\n    const quaternion = new this.context.three.Quaternion().setFromRotationMatrix(matrix);\n    this.outputs.camera.quaternion.copy(quaternion);\n    this.outputs.camera.updateProjectionMatrix();\n  };\n\n  public onDestroy = function() {\n  };\n}\n\nexport const cameraControllerType = 'sdk-component.cameraController';\nexport function CameraControllerFactory() {\n  return new CameraController();\n}\n","import { MpSdk } from \"../../mp/sdk\";\nimport { PathRendererFactory, pathRendererType } from \"./PathRenderer\";\nimport { CameraControllerFactory, cameraControllerType } from \"./CameraController\";\n\n/**\n * Registers all SDK Scene components.\n * @param {MpSdk} sdk\n */\n\nexport const initComponents = async (sdk: MpSdk | any) => {\n  await Promise.all([\n    sdk.Scene.register(pathRendererType, PathRendererFactory),\n    sdk.Scene.register(cameraControllerType, CameraControllerFactory),\n  ]);\n}","import classNames from 'classnames';\nimport { Component } from 'react';\nimport './MenuButton.scss';\n\ninterface MenuButtonProps {\n  text?: string;\n  onClick: () => void;\n}\n\nexport default class MenuButton extends Component<MenuButtonProps> {\n  \n  public render() {\n    const { text, onClick } = this.props;\n    return (\n      <div className='menu-button-container'>\n        <button type='button' className={classNames('menu-button', {'text-button': !!text})} onClick={onClick}>\n          {text ? text : \n            <img src={process.env.PUBLIC_URL + '/icons/chevron-down.svg'} className='icon-chevron-down' alt='Open Menu' />\n          }\n        </button>\n      </div>\n    );\n  }\n}","import React, { Component } from 'react';\nimport { GetSDK } from '../mp/GetSDK';\nimport { Dictionary, MpSdk, Sweep } from '../mp/sdk';\nimport './App.scss';\nimport Frame from './Frame';\nimport Menu from './ui/Menu';\nimport Pathfinder from './Pathfinder';\nimport { initComponents } from './sdk-components';\nimport { pathRendererType } from './sdk-components/PathRenderer';\nimport { cameraControllerType } from './sdk-components/CameraController';\nimport { sweepIdToPoint } from './utils';\nimport MenuButton from './ui/MenuButton';\n\nexport interface Sdk extends MpSdk {\n  Scene?: any;\n}\n\ninterface AppState {\n  currSweepId?: string;\n  selectedSweepId?: string;\n  sweepData: Sweep.SweepData[]; // put in state because changes should trigger rerender\n  sweepMap?: Dictionary<MpSdk.Sweep.ObservableSweepData>;\n  menuEnabled: boolean;\n}\n\nconst defaultUrlParams: any = {\n  m: 'opSBz3SgMg3',\n  applicationKey: 'q44m20q8yk81yi0qgixrremda',\n  title: '0',\n  qs: '1',\n  hr: '0',\n  brand: '0',\n  help: '0',\n  play: '1',\n}\n\n/**\n * This is the top level class for the app. It handles API key, model ID, and url stuff,\n * and holds references to objects/modules/components for object composition.\n * Do non-initializing SDK and UI stuff in other components/files.\n */\nexport default class App extends Component<{}, AppState> {\n\n\n  private src: string; // the url source for the sdk\n  private sdk?: Sdk;\n  private frameRef = React.createRef<HTMLIFrameElement>();\n\n  private pathNode: any; // the node for the PathRenderer component\n  private path: any; // PathRenderer component. Needed for CameraController.\n  private pathfinder?: Pathfinder;\n\n  private flyNode: any; // the node for the CameraController component\n\n  constructor(props: any) {\n    super(props);\n    const queryString = this.handleUrlParams();\n    this.src = `${process.env.PUBLIC_URL}/bundle/showcase.html?${queryString}`;\n\n    this.state = {\n      sweepData: [],\n      menuEnabled: true,\n    };\n  }\n\n  /**\n   * Parses the current url params and combines them with the default params, updating when necessary.\n   * @returns url param query string (without `?`), ready to be pasted directly into the url\n   */\n  private handleUrlParams(): string {\n    const params = new URLSearchParams(window.location.search);\n    for (const [k, v] of Object.entries(defaultUrlParams)) {\n      if (!params.has(k)) {\n        params.append(k, ''+v); // convert v to string\n      }\n    }\n    return params.toString();\n  }\n\n  public async componentDidMount() {\n    \n    this.sdk = await GetSDK('showcase', defaultUrlParams.applicationKey);\n    await initComponents(this.sdk);\n\n    const sweepData = (await this.sdk.Model.getData()).sweeps;\n    this.pathfinder = new Pathfinder(sweepData);\n    this.setState({\n      sweepData: sweepData,\n    });\n\n    this.sdk.Sweep.data.subscribe({\n      onCollectionUpdated: (collection: Dictionary<MpSdk.Sweep.ObservableSweepData>) => {\n        this.setState({\n          sweepMap: collection\n        });\n      },\n    });\n\n    this.sdk.Sweep.current.subscribe((currentSweep: any) => {\n      this.setState({\n        currSweepId: currentSweep.sid,\n      });\n    });\n  }\n\n  componentDidUpdate() {\n    this.handlePath();\n  }\n\n  private onOptionSelect = (id: string) => {\n    this.setState({\n      selectedSweepId: id,\n    });\n  }\n\n  private async handlePath() {\n    const { currSweepId, selectedSweepId, sweepMap } = this.state;\n    const { sdk, pathfinder } = this;\n\n    if (sdk && sweepMap && currSweepId && selectedSweepId && pathfinder) {\n      const path = await pathfinder.findShortestPath(currSweepId, selectedSweepId);\n      if (!path) return;\n      if (this.pathNode) this.pathNode.stop();\n      this.pathNode = await sdk.Scene.createNode();\n      this.path = this.pathNode.addComponent(pathRendererType, {\n        path: path.map(id => sweepIdToPoint(id, sweepMap)),\n        opacity: 0.7,\n        radius: 0.12,\n        stepMultiplier: 10,\n        color: 0x8df763,\n      });\n      this.pathNode.start();\n    }\n  }\n\n  private startFly = async () => {\n    const { sdk, path } = this;\n\n    if (sdk && path) {\n        this.endFly();\n        this.flyNode = await sdk.Scene.createNode();\n        const camCon = await this.flyNode.addComponent(cameraControllerType);\n        const cam = this.flyNode.addComponent('mp.camera', {\n            enabled: true,\n        });\n        camCon.bind('curve', path, 'curve');\n        cam.bind('camera', camCon, 'camera');\n        await sdk.Mode.moveTo(sdk.Mode.Mode.DOLLHOUSE, {\n          transition: sdk.Mode.TransitionType.INSTANT,\n        });\n        this.flyNode.start();\n    }\n  }\n\n  private endFly = async () => {\n    const { sdk, flyNode } = this;\n    if (sdk && flyNode) {\n      flyNode.stop();\n      //await sdk.Mode.moveTo(sdk.Mode.Mode.INSIDE);\n    }\n  }\n\n  private toggleMenu = () => {\n    this.setState({\n      menuEnabled: !this.state.menuEnabled,\n    });\n  }\n\n  public render() {\n    const { currSweepId, selectedSweepId, sweepData, menuEnabled } = this.state;\n\n    return (\n      <div className='app'>\n        <Frame src={this.src} customRef={this.frameRef} />\n        <div className='fly-buttons'>\n          <button onClick={this.startFly}>Start Fly</button>\n          <button onClick={this.endFly}>End Fly</button>\n        </div>\n        { !menuEnabled &&\n          <MenuButton onClick={this.toggleMenu} />\n        }\n        { menuEnabled &&\n          <Menu\n            currSweepId={currSweepId}\n            selectedSweepId={selectedSweepId}\n            sweepData={sweepData}\n            onChange={this.onOptionSelect}\n            onClose={this.toggleMenu}\n          />\n        }\n      </div>\n    );\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './app/App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);"],"sourceRoot":""}